const zlib = require('zlib');

class History {
  constructor () {
    /**
     * An array of passages visited.
     *
     * @property {Array} history - Passages as visited
     * @type {Array}
     */
    this.history = [];

    /**
     * An object that stores data that persists across a single user session.
     * Any other variables will not survive the user pressing back or forward.
     *
     * @property {object} state - Story state
     * @type {object}
     */
    this.state = {};

    /**
     * The name of the last checkpoint set. If none has been set, this is an
     * empty string.
     *
     * @property {string} checkpointName - name of checkpoint
     * @type {string}
     * @readonly
     */
    this.checkpointName = '';
  }

  /**
   * Push to internal history
   *
   * @function push
   * @param {string} passageName - Passage name to add
   */
  push (passageName) {
    this.history.push(passageName);
  }

  /**
   * Pops top of history array
   *
   * @function pop
   * @returns {string} - Returns top of array
   */
   pop () {
    return this.history.pop();
  }

  /**
   * Returns Brotli compressed string as base64
   *
   * @function saveHash
   * @returns {string} - Returns the hash
   */
  saveToHash () {
    const history = JSON.stringify({
      state: this.state,
      history: this.history,
      checkpointName: this.checkpointName
    });

    return zlib.brotliCompressSync(history).toString('base64');
  }

  /**
   * Tries to restore the story state from a hash value generated by saveToHash().
   *
   * @function restoreFromHash
   * @param {string} hash - Hash to restore from
   */
  restoreFromHash (hash) {
    // Set a default value
    let jsonHistory = null;

    try {
      jsonHistory = zlib.brotliDecompressSync(Buffer.from(hash, 'base64'));
    } catch(e) {
      // Invalid data error
      throw new Error("Invalid Brotli data");
    }

    let backup = null;

    try {
      // Parse the string back into object
      backup = JSON.parse(jsonHistory);
    } catch(e) {
      // No JSON data
      throw new Error("Compressed data not valid JSON");
    }

    if(Object.hasOwn(backup, 'state')) {
      this.state = backup.state;
    }

    if(Object.hasOwn(backup, 'history')) {
      if(Array.isArray(backup.history)) {
        this.history = backup.history;
      }
    }

    if(Object.hasOwn(backup, 'checkpointName')) {
      this.checkpointName = backup.checkpointName;
    }
  }

  /**
   * Returns true if the named passage exists within the history array
   *
   * @function hasVisited
   * @param {string|array} passageName - Name(s) of passage to check
   * @returns {boolean} - True if passage(s) in history; false otherwise
   */
  hasVisited (passageName) {
    let result = false;

    if(Array.isArray(passageName)) {
      result = passageName.every((p) => {
        return this.history.includes(p);
      });
    } else {
      result = this.history.some((p) => {
        return p === passageName;
      });
    }

    return result;
  }
}

module.exports = History;
